import numpy as np
from scipy.interpolate import interp1d
def VERINT(X,Y,N,XIN):
    if X[0]>X[-1]:
        X = X[::-1]
        Y = Y[::-1]
    YOUT = np.interp(x=XIN,xp=X,fp=Y)
    return YOUT

# def VERINT(X,Y,N,XIN):
#     f = interp1d(X,Y)
#     YOUT = f(XIN)
#     return YOUT

# def VERINT(X,Y,N,XIN):
#     N = len(X)
#     # increasing
#     # print('X',X)
#     # print('Y',Y)
#     # print('XIN',XIN)
#     index = -1
#     if X[0] > X[-1]:
#         Xarr = X[::-1]
#         Yarr = Y[::-1]
#     else:
#         Xarr = X[:]
#         Yarr = Y[:]
#     for I in range(N):
#         if Xarr[I] > XIN:
#             index = I
#             break
#     if index == -1:
#         index = N-1
#     if index == 0:
#         index = 1
#     YOUT = Yarr[index-1] \
#         + (Yarr[index]-Yarr[index-1])\
#         * (XIN-Xarr[index-1])/(Xarr[index]-Xarr[index-1])
#     if Xarr[index-1] == Xarr[index]:
#         YOUT = Y[index]
#     # print('index',index)
#     # if YOUT < 0:
#         # print('X',X)
#         # print('Y',Y)
#         # print('XIN',XIN)

#     return YOUT

def interpvivien_point(xlon, xlat, xp, vp, vt, vvmr,
    model_longitudes, model_lattitudes,
    sub_stellar_point_longitude=180):
    """
    Find atmospheric conditions (temperature and gas volume mixing ratios) as
    a function of pressure at the input location by interpolating a 3D
    atmospheric model. The location is specified by longitude and lattitude.

    Parameters
    ----------
    xlon : real
        Input longitude
    xlat : real
        Input lattitude
    xp : ndarray
        Pressre grid for the interpolated model into.
        Has dimension NPRO
    vp : ndarray
        Pressure grid of the atmospheric model. NPRESS
    vt : ndarray
        Temperature model.
        Has dimension NLON x NLAT x NP.
    vvmr : ndarray
        VMR model.
        NLON x NLAT x NP x NVMR
    model_longitudes : ndarray
        Longitude grid of the atmospheric model.
    model_lattitudes : ndarray
        Lattitude grid of the atmospheric model.
    sub_stellar_point_longitude : real
        The longitude of the substellar point defined in the model atmosphere in
        the interpolated frame of refernce.

    Returns
    -------
    T : ndarray
        Temperature model interpolated to (xlon,xlat). NPRO
    VMR : ndarray
        VMR model interpolated to (xlon,xlat). NPRO

    """
    globalT = vt
    assert xlat<=90 and xlat>=-90
    NPRO = len(xp)

    # dimension parameters from Vivien's GCM
    NPRESS = 53
    NLON = 64
    NLAT = 32
    NGV = 6
    VLON = model_longitudes
    VLAT = model_lattitudes

    # Convert P from bar to atm and convert to log
    logVP = np.log(vp/1.013e5)
    """CARE"""
    logVP = vp
    # print('logVP',logVP)
    # print('logVP',logVP)

    # Vivien has 0 longitude as sub-stellar point. He we have 180
    # Hence need to add 180 to all longitudes
    """This step should solve all lon lat coordinate problems
    Can safely use planetocentric lon lat coordinates generated by
    previous code, which takes in STELLAR PHASE and spits out
    PLANETOCENTRIC COORDINATES"""
    VLON = VLON + sub_stellar_point_longitude
    # print('VLON',VLON)

    #  Find closest point in stored array
    JLAT = -1
    for I in range(NLAT-1):
        if xlat >= VLAT[I] and xlat <= VLAT[I+1]:
            JLAT = I
            FLAT = (xlat-VLAT[I])/(VLAT[I+1]-VLAT[I])

    if JLAT < 0:
        if xlat < VLAT[0]:
            JLAT = 0
            FLAT = 0
        if xlat >= VLAT[-1]:
            JLAT = NLAT - 1
            FLAT = 1

    JLON1 = -1
    JLON2 = -1
    for I in range(NLON-1):
        if xlon >= VLON[I] and xlon <= VLON[I+1]:
            JLON1 = I
            JLON2 = I+1
            FLON = (xlon-VLON[I])/(VLON[I+1]-VLON[I])
    if JLON1 < 0:
        if xlon < VLON[0]:
            # xlon must be in range 0. to VLON[0]
            JLON1 = NLON - 1
            JLON2 = 0
            FLON = (xlon+360-VLON[-1])/(VLON[0]+360-VLON[-1])
        if xlon >= VLON[-1]:
            # xlon must be in range VLON[-1] to 360
            JLON1 = NLON - 1
            JLON2 = 0
            FLON = (xlon - VLON[-1])/(VLON[0]+360-VLON[-1])
    # print('JLAT',JLAT)
    # print('JLON',JLON1,JLON2)
    # Temperature interpolation array
    VY1 = globalT[JLON1,JLAT,:]
    VY2 = globalT[JLON2,JLAT,:]
    VY3 = globalT[JLON2,JLAT+1,:]
    VY4 = globalT[JLON1,JLAT+1,:]
    # print('VY1',VY1)
    # print('VY2',VY2)
    # print('VY3',VY3)
    # print('VY4',VY4)

    # Define VERTINT
    # SUBROUTINE VERINT(X,Y,N,YOUT,XIN)
    # interpolate T
    # print('xp',xp)
    interped_T = np.zeros(NPRO)
    for IPRO in range(NPRO):
        # convert pressure to atm then to log
        LP1 = np.log(xp[IPRO]/1.013e5)
        LP1 = xp[IPRO]
        # print('LP1',LP1)
        # LP1 = xp[IPRO]
        # print('LP1',LP1)
        Y1 = VERINT(logVP,VY1,NPRESS,LP1)
        Y2 = VERINT(logVP,VY2,NPRESS,LP1)
        Y3 = VERINT(logVP,VY3,NPRESS,LP1)
        Y4 = VERINT(logVP,VY4,NPRESS,LP1)
        interped_T[IPRO] = (1.0-FLON)*(1.0-FLAT)*Y1 + FLON*(1.0-FLAT)*Y2 \
            + FLON*FLAT*Y3 + (1.0-FLON)*FLAT*Y4
        # print('LP1',LP1)
        # print('Y1',Y1)
        # print('Y2',Y2)
        # print('Y3',Y3)
        # print('Y4',Y4)
        # print('interped_T[IPRO]',interped_T[IPRO])

    NVMR = NGV
    interped_VMR = np.zeros((NPRO,NVMR))
    for IVMR in range(NVMR):
        VY1 = vvmr[JLON1,JLAT,:,IVMR]
        VY2 = vvmr[JLON2,JLAT,:,IVMR]
        VY3 = vvmr[JLON2,JLAT+1,:,IVMR]
        VY4 = vvmr[JLON1,JLAT+1,:,IVMR]
        for I in range(NPRO):
            LP1 = np.log(xp[IPRO]/1.013e5)
            Y1 = VERINT(logVP,VY1,NPRESS,LP1)
            Y2 = VERINT(logVP,VY2,NPRESS,LP1)
            Y3 = VERINT(logVP,VY3,NPRESS,LP1)
            Y4 = VERINT(logVP,VY4,NPRESS,LP1)
            interped_VMR[I,IVMR] = (1.0-FLON)*(1.0-FLAT)*Y1 + FLON*(1.0-FLAT)*Y2\
                + FLON*FLAT*Y3 + (1.0-FLON)*FLAT*Y4

    # print('interped_T',interped_T)
    # print('interped_VMR',interped_VMR)
    return interped_T, interped_VMR
