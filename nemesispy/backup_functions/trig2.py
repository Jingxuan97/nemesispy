import numpy as np
from numba import jit

@jit(nopython=True)
def VERINT(X,Y,N,XIN):
    if X[0]>X[-1]:
        X = X[::-1]
        Y = Y[::-1]
    YOUT = np.interp(x=XIN,xp=X,fp=Y)
    return YOUT

@jit(nopython=True)
def interpvivien_point(xlon, xlat, xp, vp, vt, vvmr,
    mod_lon, mod_lat,
    longitude_shift=180):
    """
    Find atmospheric conditions (temperature and gas volume mixing ratios) as
    a function of pressure at the input location by interpolating a 3D
    atmospheric model. The location is specified by longitude and lattitude.

    Parameters
    ----------
    xlon : real
        Input longitude
    xlat : real
        Input lattitude
    xp : ndarray
        Pressre grid for the interpolated model into.
        Has dimension NPRO
    vp : ndarray
        Pressure grid of the atmospheric model. NPRESS
    vt : ndarray
        Temperature model.
        Has dimension NLON x NLAT x NP.
    vvmr : ndarray
        VMR model.
        NLON x NLAT x NPRESS x NVMR
    mod_lon : ndarray
        Longitude grid of the atmospheric model.
    mod_lat : ndarray
        Lattitude grid of the atmospheric model.
    longitude_shift : real
        The longitude shift between the longitude-lattitude coordinate system
        of the 3D model to our coordinate system.

    Returns
    -------
    T : ndarray
        Temperature model interpolated to (xlon,xlat). NPRO
    VMR : ndarray
        VMR model interpolated to (xlon,xlat). NPRO

    """
    globalT = vt
    assert xlat<=90 and xlat>=-90
    NPRO = len(xp)

    # Dimension parameters of the atmospheric model
    NLON,NLAT,NPRESS,NVMR = vvmr.shape
    mod_lon = mod_lon
    mod_lat = mod_lat

    # Convert to log pressure
    logVP = np.log(vp)

    # Vivien has 0 longitude as sub-stellar point. We have 180
    # Hence need to add 180 to all longitudes
    """This step should solve all lon lat coordinate problems
    Can safely use planetocentric lon lat coordinates generated by
    previous code, which takes in STELLAR PHASE and spits out
    PLANETOCENTRIC COORDINATES"""
    """Longitude-Lattitude coordinate system might differ from ours. Add the
    longitude of the antistellar point in our frame of reference to the
    model longitude grid.
    """
    mod_lon = np.mod(mod_lon + longitude_shift,360)
    # print('mod_lon',mod_lon)

    #  Find closest point in stored array
    JLAT = -1
    for I in range(NLAT-1):
        if xlat >= mod_lat[I] and xlat <= mod_lat[I+1]:
            JLAT = I
            FLAT = (xlat-mod_lat[I])/(mod_lat[I+1]-mod_lat[I])

    if JLAT < 0:
        if xlat < mod_lat[0]:
            JLAT = 0
            FLAT = 0
        if xlat >= mod_lat[-1]:
            JLAT = NLAT - 1
            FLAT = 1

    JLON1 = -1
    JLON2 = -1
    for I in range(NLON-1):
        if xlon >= mod_lon[I] and xlon <= mod_lon[I+1]:
            JLON1 = I
            JLON2 = I+1
            FLON = (xlon-mod_lon[I])/(mod_lon[I+1]-mod_lon[I])
    if JLON1 < 0:
        if xlon < mod_lon[0]:
            # xlon must be in range 0. to mod_lon[0]
            JLON1 = NLON - 1
            JLON2 = 0
            FLON = (xlon+360-mod_lon[-1])/(mod_lon[0]+360-mod_lon[-1])
        if xlon >= mod_lon[-1]:
            # xlon must be in range mod_lon[-1] to 360
            JLON1 = NLON - 1
            JLON2 = 0
            FLON = (xlon - mod_lon[-1])/(mod_lon[0]+360-mod_lon[-1])

    # Output arrays
    interped_T = np.zeros(NPRO)
    interped_VMR = np.zeros((NPRO,NVMR))

    #Â Temperature interpolation array
    tempVY1 = globalT[JLON1,JLAT,:]
    tempVY2 = globalT[JLON2,JLAT,:]
    tempVY3 = globalT[JLON2,JLAT+1,:]
    tempVY4 = globalT[JLON1,JLAT+1,:]
    for IPRO in range(NPRO):
        # convert pressure to atm then to log
        LP1 = np.log(xp[IPRO])
        tempY1 = VERINT(logVP,tempVY1,NPRESS,LP1)
        tempY2 = VERINT(logVP,tempVY2,NPRESS,LP1)
        tempY3 = VERINT(logVP,tempVY3,NPRESS,LP1)
        tempY4 = VERINT(logVP,tempVY4,NPRESS,LP1)
        interped_T[IPRO] = (1.0-FLON)*(1.0-FLAT)*tempY1 + FLON*(1.0-FLAT)*tempY2 \
            + FLON*FLAT*tempY3 + (1.0-FLON)*FLAT*tempY4
        for IVMR in range(NVMR):
            gasVY1 = vvmr[JLON1,JLAT,:,IVMR]
            gasVY2 = vvmr[JLON2,JLAT,:,IVMR]
            gasVY3 = vvmr[JLON2,JLAT+1,:,IVMR]
            gasVY4 = vvmr[JLON1,JLAT+1,:,IVMR]
            gasY1 = VERINT(logVP,gasVY1,NPRESS,LP1)
            gasY2 = VERINT(logVP,gasVY2,NPRESS,LP1)
            gasY3 = VERINT(logVP,gasVY3,NPRESS,LP1)
            gasY4 = VERINT(logVP,gasVY4,NPRESS,LP1)
            interped_VMR[IPRO,IVMR] = (1.0-FLON)*(1.0-FLAT)*gasY1 + FLON*(1.0-FLAT)*gasY2\
                + FLON*FLAT*gasY3 + (1.0-FLON)*FLAT*gasY4

    return interped_T, interped_VMR